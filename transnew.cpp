// function implements the equations of GR polarized radiative transfer in polarized coordinates
int trans (doub llog, const doub yyy[], doub ff[], void *pas) {

     // sinh transformation of affine parameter t allows to convert scales close to the BH and far from the BH to a single uniform grid
     doub det=-3.*cosh(llog),
          t=1.+ 3.* sinh(llog)/r0;
	 //evaluation of plasma emissivities/absorptivities/rotativities at a given point
#include "evalpointzero.cpp"

    //local auxiliary variables
    doub cosqs=cos(yyy[2]), 
		 sinqs=sin(yyy[2]), 
		 frsq=fr*fr, 
		 frcu=frsq*fr, 
		 sinths=sin(yyy[3]), 
		 cosths=cos(yyy[3]);

	//radiative transfer equations in polarized coordinates
    //this piece of code is autogenerated in Mathematica
    //RG:CHECK WHY /frsq ? It should be frcu ?!
    ff[0]=(det*(jIc - frcu*(aIc*yyy[0] + (aVc*cosths +aQc*cos2k*cosqs*sinths + aQc*sin2k*sinqs*sinths)*yyy[1])))/frsq;

    // RG:CHECK! APPEARS TO BE OUT OF ORDER... ff[0],***-->ff[2],ff[1]<--***,ff[3],ff[4]
    ff[2]=(det*(cosqs*sin2k - cos2k*sinqs)*(jQc - aQc*frcu*yyy[0]) - det*frcu*(cos2k*cosqs*cosths*rQc + cosths*rQc*sin2k*sinqs -rVc*sinths)*yyy[1])/(frsq*sinths*yyy[1]);
    ff[1]= (det*((cos2k*cosqs + sin2k*sinqs)*sinths*(jQc - aQc*frcu*yyy[0]) + cosths*(jVc -aVc*frcu*yyy[0]) - aIc*frcu*yyy[1]))/frsq;

    ff[3]=(det*(-(jVc*sinths) + aVc*frcu*sinths*yyy[0] + cos2k*cosqs*cosths*(jQc - aQc*frcu*yyy[0]) + cosths*sin2k*sinqs*(jQc - aQc*frcu*yyy[0]) + cosqs*frcu*rQc*sin2k*yyy[1] -cos2k*frcu*rQc*sinqs*yyy[1]))/(frsq*yyy[1]);

    if ( !strcmp(image_diagnostic,"column densities") ) {
      ff[4]= det*(rho/frsq); // ~> jIc=rho <=> column density image? // v5 // closest to Avery's code so far
    }
    else if ( !strcmp(image_diagnostic,"melrose") ) {
      ff[4]= det*(-fr*aIc_approx*yyy[4] + jIc_approx/frsq);
    }
    // else
    //   printf(YELLOW"[transnew.cpp]: "RED"CHOOSE IMAGE DIAGNOSTICS in [global_variables.cpp]"RESET"\n");
    //   exit(1);

    /*******************************/
    // ADD NON-THERMAL CONTRIBUTION 
    //
    // RG:TODO: ULTIMATELY WANT SEPARATE VARIABLES FOR THESE FOR DIAGNOSTIC PURPOSES

    //char emissivity[16]="th"; // RG: MAKE THIS A USER CHOICE e.g. inside win_lin_Jon.c
    //if (emissivity=="nth"){

    if (nth){
      // CHANGE += -> -= for TESTING PURPOSES 
      // use new thermal and subtract from old thermal (expect small values)
      // USE OLD absorption
      ff[0]+=(det*(jIc_nth - frcu*(aIc_nth*yyy[0] + (aVc_nth*cosths +aQc_nth*cos2k*cosqs*sinths + aQc_nth*sin2k*sinqs*sinths)*yyy[1])))/frsq;

      ff[2]+=(det*(cosqs*sin2k - cos2k*sinqs)*(jQc_nth - aQc_nth*frcu*yyy[0]) - det*frcu*(cos2k*cosqs*cosths*rQc + cosths*rQc*sin2k*sinqs -rVc*sinths)*yyy[1])/(frsq*sinths*yyy[1]);
      ff[1]+= (det*((cos2k*cosqs + sin2k*sinqs)*sinths*(jQc_nth - aQc_nth*frcu*yyy[0]) + cosths*(jVc_nth -aVc_nth*frcu*yyy[0]) - aIc_nth*frcu*yyy[1]))/frsq;
      ff[3]+=(det*(-(jVc_nth*sinths) + aVc_nth*frcu*sinths*yyy[0] + cos2k*cosqs*cosths*(jQc_nth - aQc_nth*frcu*yyy[0]) + cosths*sin2k*sinqs*(jQc_nth - aQc_nth*frcu*yyy[0]) + cosqs*frcu*rQc*sin2k*yyy[1] -cos2k*frcu*rQc*sinqs*yyy[1]))/(frsq*yyy[1]);
      ff[4]+= det*(-fr*aIc_approx*yyy[4] + jIc_approx/frsq);
    }


    //Check for NANs
    for (int index=0; index<=4; index++){
      if(isnan(ff[index])) {
        printf(YELLOW"[transnew.cpp]: "RED"Error in radiative transfer ff[%d] is NAN.\n...Exiting...\n"RESET,index); 
        //RG: for thickdisk7 iteration fieldline0001.bin sin2k is nan (->k->B?)
        printf(YELLOW"[transnew.cpp]: "RED"NAN search: det=%e,jIc=%e,frcu=%e,aIc=%e,yyy[0]=%e,aVc=%e,cosths=%e,aQc=%e,cos2k=%e,cosqs=%e,sinths=%e,aQc=%e,sin2k=%e,sinsq=%e,yyy[1]=%e,frsq=%e\n"RESET,det,jIc,frcu,aIc,yyy[0],aVc,cosths,aQc,cos2k,cosqs,sinths,aQc,sin2k,sinqs,yyy[1],frsq);
        printf(YELLOW"[transnew.cpp]: "RED"NAN search: sin2k=-2.*Be1*Be2/(Be1*Be1+Be2*Be2): Be1=%e Be2=%e B[1]=%e B[2]=%e B[3]=%e\n"RESET,Be1,Be2,B[1],B[2],B[3]);
        //t_solvetrans += (clock() - t_b4_solvetrans) / (doub)CLOCKS_PER_SEC;
	    exit(1);
      };
    };

    return(0);
}
